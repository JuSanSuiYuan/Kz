/*
 * Kz语言 - Python风格match语法示例
 * 许可证：木兰2.0（Mulan PSL v2）
 * 行尾序列：LF（\n）
 */

// 导入必要的模块
import std.io;
import std.math;
import std.container;

// 定义一个枚举类型用于演示
枚举 颜色 {
    红,
    绿,
    蓝,
    黄,
    紫
}

// 定义一个结构体用于演示
结构体 点 {
    x: i32,
    y: i32
}

// 定义一个可选类型的结果枚举
枚举 结果<T, E> {
    成功(T),
    失败(E)
}

// 使用Python风格的match语法的函数示例
函数 处理颜色(颜色值: 颜色): string {
    令 结果 = match 颜色值 {
        颜色.红 => "红色代表热情",
        颜色.绿 => "绿色代表自然",
        颜色.蓝 => "蓝色代表宁静",
        颜色.黄 | 颜色.紫 => "这是一种鲜艳的颜色",
        _ => "未知颜色"
    };
    
    返回 结果;
}

// 使用中文关键字"设"和"令"结合match语法
函数 处理坐标(坐标点: 点): string {
    设 区域 = match 坐标点 {
        点{x=0, y=0} => "原点",
        点{x=x, y=0} if x > 0 => "在x轴正半轴",
        点{x=0, y=y} if y > 0 => "在y轴正半轴",
        点{x=x, y=y} if x > 0 && y > 0 => "在第一象限",
        点{x=x, y=y} if x < 0 && y > 0 => "在第二象限",
        点{x=x, y=y} if x < 0 && y < 0 => "在第三象限",
        点{x=x, y=y} if x > 0 && y < 0 => "在第四象限",
        _ => "其他位置"
    };
    
    返回 区域;
}

// 使用match处理结果类型
函数 处理计算结果(结果值: 结果<i32, string>): string {
    match 结果值 {
        结果.成功(value) => return f"计算成功，结果为: {value}",
        结果.失败(error) => return f"计算失败，错误: {error}"
    }
}

// 使用match处理数组和元组
函数 分析数据结构(数据: any): string {
    match 数据 {
        [] => "空数组",
        [x] => f"单元素数组: {x}",
        [x, y] => f"双元素数组: {x}, {y}",
        [x, y, z] => f"三元素数组: {x}, {y}, {z}",
        [x, y, ..] => f"多元素数组，前两个元素: {x}, {y}",
        (x, y) => f"二元组: ({x}, {y})",
        _ => "未知数据结构"
    }
}

// 使用match进行类型匹配
函数 类型匹配示例(值: any): string {
    match 类型(值) {
        类型(i32) => "这是一个32位整数",
        类型(f64) => "这是一个双精度浮点数",
        类型(string) => "这是一个字符串",
        类型(bool) => "这是一个布尔值",
        类型(颜色) => "这是一个颜色枚举",
        类型(点) => "这是一个点结构体",
        _ => "其他类型"
    }
}

// 主函数
函数 主(): i32 {
    // 测试颜色匹配
    设 颜色列表 = [颜色.红, 颜色.绿, 颜色.黄];
    for 颜色 in 颜色列表 {
        io.println(处理颜色(颜色));
    }
    
    // 测试坐标匹配
    设 坐标列表 = [点{x=0, y=0}, 点{x=10, y=0}, 点{x=5, y=5}];
    for 点 in 坐标列表 {
        io.println(f"点({点.x}, {点.y}) 位于 {处理坐标(点)}");
    }
    
    // 测试结果类型匹配
    设 成功结果 = 结果.成功(42);
    设 失败结果 = 结果.失败("除以零错误");
    io.println(处理计算结果(成功结果));
    io.println(处理计算结果(失败结果));
    
    // 测试数据结构匹配
    io.println(分析数据结构([]));
    io.println(分析数据结构([1]));
    io.println(分析数据结构([1, 2]));
    io.println(分析数据结构([1, 2, 3]));
    io.println(分析数据结构([1, 2, 3, 4]));
    io.println(分析数据结构((1, 2)));
    
    // 测试类型匹配
    io.println(类型匹配示例(42));
    io.println(类型匹配示例(3.14));
    io.println(类型匹配示例("Kz语言"));
    io.println(类型匹配示例(true));
    io.println(类型匹配示例(颜色.蓝));
    io.println(类型匹配示例(点{x=1, y=2}));
    
    // 使用match-case进行复杂条件匹配
    设 数值 = 42;
    match 数值 {
        0 => io.println("零"),
        1...9 => io.println("一位数"),
        10...99 => io.println("两位数"),
        100...999 => io.println("三位数"),
        n if n % 2 == 0 => io.println("偶数"),
        n if n % 2 == 1 => io.println("奇数"),
        _ => io.println("未知数值")
    }
    
    返回 0;
}