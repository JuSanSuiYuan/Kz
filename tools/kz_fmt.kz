/*
 * Kz语言格式化工具 (kz fmt)
 * 许可证：木兰2.0（Mulan PSL v2）
 * 行尾序列：LF（\n）
 */

// 导入必要的模块
import std.io;
import std.container;
import std.string;
import std.filesystem;
import std.process;
import std.regex;
import std.error;

// 定义格式化选项结构体
结构体 格式化选项 {
    缩进宽度: i32 = 4,
    使用空格: bool = true,
    最大行宽: i32 = 80,
    移除尾部空白: bool = true,
    标准化行尾: bool = true,
    行尾样式: string = "LF",
    对齐操作符: bool = true,
    空格在括号内: bool = false,
    空格在运算符周围: bool = true,
    新行在大括号前: bool = false
}

// Kz格式化器类
类 Kz格式化器 {
    私有 options: 格式化选项;
    私有 模式: [Regex];
    
    构造函数(options: 格式化选项 = 格式化选项 {}) {
        this.options = options;
        this.初始化模式();
    }
    
    // 初始化正则表达式模式
    私有 函数 初始化模式(): void {
        // 定义各种格式化所需的正则表达式
        this.模式 = [
            Regex("\\s+"),                      // 空白字符
            Regex("^(\\s*)"),                  // 行首缩进
            Regex("([;,])\\s*"),               // 分号和逗号后空格
            Regex("\\s*([{}()\[\]])\\s*"),     // 括号周围空格
            Regex("\\s*([+\-*/%=<>!&|^~?:,;])\\s*"), // 运算符周围空格
            Regex("\\s+(\\r?\\n)")           // 尾部空白
        ];
    }
    
    // 格式化单个文件
    函数 格式化文件(文件路径: string): bool {
        try {
            // 检查文件是否存在
            if !filesystem.exists(文件路径) {
                io.println(f"错误: 文件 {文件路径} 不存在");
                return false;
            }
            
            // 读取文件内容
            设 内容 = filesystem.read_text(文件路径);
            
            // 执行格式化
            设 格式化后内容 = this.格式化(内容);
            
            // 写回文件
            filesystem.write_text(文件路径, 格式化后内容);
            io.println(f"已格式化: {文件路径}");
            
            return true;
        } catch (e) {
            io.println(f"格式化文件 {文件路径} 时出错: {e.message}");
            return false;
        }
    }
    
    // 格式化内容
    函数 格式化(内容: string): string {
        设 结果 = 内容;
        
        // 标准化行尾
        if this.options.标准化行尾 {
            结果 = 结果.replace("\r\n", "\n"); // 将CRLF转换为LF
            结果 = 结果.replace("\r", "\n");   // 将CR转换为LF
            
            if this.options.行尾样式 == "CRLF" {
                结果 = 结果.replace("\n", "\r\n"); // 将LF转换为CRLF
            }
        }
        
        // 移除尾部空白
        if this.options.移除尾部空白 {
            设 行 = 结果.split("\n");
            设 新行 = [string];
            
            for 行内容 in 行 {
                新行.append(行内容.rstrip());
            }
            
            结果 = 新行.join("\n");
        }
        
        // 格式化缩进
        结果 = this.格式化缩进(结果);
        
        // 格式化操作符
        结果 = this.格式化操作符(结果);
        
        // 格式化括号
        结果 = this.格式化括号(结果);
        
        // 格式化逗号和分号
        结果 = this.格式化逗号和分号(结果);
        
        // 确保文件以换行符结束
        if 结果.length() > 0 && !结果.ends_with("\n") {
            结果 += "\n";
        }
        
        return 结果;
    }
    
    // 格式化缩进
    私有 函数 格式化缩进(内容: string): string {
        设 行 = 内容.split("\n");
        设 新行 = [string];
        设 缩进级别 = 0;
        设 缩进字符 = if this.options.使用空格 { " ".repeat(this.options.缩进宽度) } else { "\t" };
        
        for 行内容 in 行 {
            // 去除原缩进
            设 修剪后 = 行内容.lstrip();
            
            // 处理闭合大括号，减少缩进级别
            if 修剪后.starts_with("}") || 修剪后.starts_with("]") {
                缩进级别 = max(0, 缩进级别 - 1);
            }
            
            // 添加正确的缩进
            设 缩进 = 缩进字符.repeat(缩进级别);
            新行.append(缩进 + 修剪后);
            
            // 处理开放大括号，增加缩进级别
            for 字符 in 修剪后 {
                if 字符 == '{' || 字符 == '[' {
                    缩进级别 += 1;
                } else if 字符 == '}' || 字符 == ']' {
                    缩进级别 = max(0, 缩进级别 - 1);
                }
            }
        }
        
        return 新行.join("\n");
    }
    
    // 格式化操作符
    私有 函数 格式化操作符(内容: string): string {
        设 结果 = 内容;
        
        // 处理赋值操作符
        结果 = 结果.replace("=", " = ");
        
        // 处理算术操作符
        结果 = 结果.replace("+", " + ");
        结果 = 结果.replace("-", " - ");
        结果 = 结果.replace("*", " * ");
        结果 = 结果.replace("/", " / ");
        结果 = 结果.replace("%", " % ");
        
        // 处理比较操作符
        结果 = 结果.replace("<", " < ");
        结果 = 结果.replace(">", " > ");
        结果 = 结果.replace("<=", " <= ");
        结果 = 结果.replace(">=", " >= ");
        结果 = 结果.replace("==", " == ");
        结果 = 结果.replace("!=", " != ");
        
        // 处理逻辑操作符
        结果 = 结果.replace("&&", " && ");
        结果 = 结果.replace("||", " || ");
        结果 = 结果.replace("!", "! ");
        
        // 移除多余空格
        结果 = Regex("\\s+").replace_all(结果, " ");
        
        // 恢复特殊情况
        结果 = 结果.replace(" ! ", "!");
        
        return 结果;
    }
    
    // 格式化括号
    私有 函数 格式化括号(内容: string): string {
        设 结果 = 内容;
        
        if !this.options.空格在括号内 {
            // 移除括号内的空格
            结果 = Regex("\\(\\s+").replace_all(结果, "(");
            结果 = Regex("\\s+\\)").replace_all(结果, ")");
            结果 = Regex("\\[\\s+").replace_all(结果, "[");
            结果 = Regex("\\s+\\]").replace_all(结果, "]");
            结果 = Regex("\\{\\s+").replace_all(结果, "{");
            结果 = Regex("\\s+\\}").replace_all(结果, "}");
        }
        
        return 结果;
    }
    
    // 格式化逗号和分号
    私有 函数 格式化逗号和分号(内容: string): string {
        设 结果 = 内容;
        
        // 逗号后添加空格
        结果 = Regex(",\\s*").replace_all(结果, ", ");
        
        // 分号后添加空格（如果不在行尾）
        结果 = Regex(";\\s*(?!$)").replace_all(结果, "; ");
        
        return 结果;
    }
    
    // 格式化目录
    函数 格式化目录(目录路径: string): i32 {
        设 成功计数 = 0;
        设 失败计数 = 0;
        
        try {
            // 遍历目录中的所有.kz文件
            设 文件 = filesystem.list_files(目录路径, "**.kz");
            
            for 文件路径 in 文件 {
                if this.格式化文件(文件路径) {
                    成功计数 += 1;
                } else {
                    失败计数 += 1;
                }
            }
            
            io.println(f"\n格式化完成:");
            io.println(f"  成功: {成功计数} 个文件");
            io.println(f"  失败: {失败计数} 个文件");
            
            return 成功计数;
        } catch (e) {
            io.println(f"遍历目录 {目录路径} 时出错: {e.message}");
            return 0;
        }
    }
}

// 显示帮助信息
函数 显示帮助(): void {
    io.println("Kz语言格式化工具 (kz fmt) 使用帮助:");
    io.println();
    io.println("用法: kz fmt [选项] <文件或目录>");
    io.println();
    io.println("选项:");
    io.println("  -h, --help             显示此帮助信息");
    io.println("  -v, --version          显示版本信息");
    io.println("  -i, --indent <宽度>    设置缩进宽度 (默认: 4)");
    io.println("  --tabs                 使用制表符进行缩进 (默认使用空格)");
    io.println("  --spaces               使用空格进行缩进 (默认)");
    io.println("  --line-length <长度>   设置最大行宽 (默认: 80)");
    io.println("  --no-trim              不移除行尾空白");
    io.println("  --crlf                 使用CRLF行尾序列");
    io.println("  --lf                   使用LF行尾序列 (默认)");
    io.println("  --check                检查是否需要格式化，不实际修改文件");
    io.println();
    io.println("示例:");
    io.println("  kz fmt main.kz          # 格式化单个文件");
    io.println("  kz fmt src/             # 格式化目录中的所有.kz文件");
    io.println("  kz fmt -i 2 main.kz     # 使用2个空格缩进");
    io.println("  kz fmt --tabs main.kz   # 使用制表符缩进");
}

// 显示版本信息
函数 显示版本(): void {
    io.println("Kz格式化工具 (kz fmt) 版本 1.0.0");
    io.println("用于格式化Kz语言代码");
    io.println("许可证: 木兰2.0 (Mulan PSL v2)");
}

// 主函数
函数 主(): i32 {
    设 参数 = process.args();
    
    // 检查是否需要显示帮助或版本信息
    if 参数.长度() == 1 || 参数.contains("--help") || 参数.contains("-h") {
        显示帮助();
        return 0;
    }
    
    if 参数.contains("--version") || 参数.contains("-v") {
        显示版本();
        return 0;
    }
    
    // 解析参数
    设 options = 格式化选项 {};
    设 文件路径 = "";
    设 检查模式 = false;
    
    设 i = 1;
    while i < 参数.长度() {
        match 参数[i] {
            "-i", "--indent" => {
                if i + 1 < 参数.长度() {
                    options.缩进宽度 = 参数[i + 1].parse_i32();
                    i += 2;
                } else {
                    io.println("错误: --indent 需要指定宽度");
                    return 1;
                }
            },
            "--tabs" => {
                options.使用空格 = false;
                i += 1;
            },
            "--spaces" => {
                options.使用空格 = true;
                i += 1;
            },
            "--line-length" => {
                if i + 1 < 参数.长度() {
                    options.最大行宽 = 参数[i + 1].parse_i32();
                    i += 2;
                } else {
                    io.println("错误: --line-length 需要指定长度");
                    return 1;
                }
            },
            "--no-trim" => {
                options.移除尾部空白 = false;
                i += 1;
            },
            "--crlf" => {
                options.行尾样式 = "CRLF";
                i += 1;
            },
            "--lf" => {
                options.行尾样式 = "LF";
                i += 1;
            },
            "--check" => {
                检查模式 = true;
                i += 1;
            },
            _ => {
                文件路径 = 参数[i];
                i += 1;
            }
        }
    }
    
    // 检查是否指定了文件或目录
    if 文件路径 == "" {
        io.println("错误: 请指定文件或目录");
        return 1;
    }
    
    // 创建格式化器
    设 formatter = Kz格式化器::new(options);
    
    // 检查目标是文件还是目录
    if filesystem.is_file(文件路径) {
        if formatter.格式化文件(文件路径) {
            return 0;
        } else {
            return 1;
        }
    } else if filesystem.is_directory(文件路径) {
        formatter.格式化目录(文件路径);
        return 0;
    } else {
        io.println(f"错误: {文件路径} 不是有效的文件或目录");
        return 1;
    }
}